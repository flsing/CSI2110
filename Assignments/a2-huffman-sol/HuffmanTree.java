import java.util.Arrays;
import java.util.Iterator;

/**
 * HuffmanTree creates and stores a Huffman tree based on Huffman nodes (an inner class),
 * It also provide a series of methods for encoding and decoding.
 * It uses a BitFeedOut which allows a stream of bits be sent continuously 
 * to be used for encoding.
 * It also uses an Iterator<Byte> which allows a stream of bits to be read continuously
 * to be used when decoding.
 * 
 * @author Lucia Moura
 */

public class HuffmanTree {
	
 public static int EndOfText=((int)'\uffff')+1; //special symbol created to indicate end of text
	
 HuffmanNode root=null; // root of the Huffman tree
 HuffmanNode[] leafWhereLetterIs;   // array indexed by characters, storing a reference to 
 									// the Huffman Node (leaf) in which the character is stored

 
 // Constructor receives frequency information which is used to call BuildTree
 public HuffmanTree (LetterFrequencies letterFreq) {
	 
	 root=BuildTree (letterFreq.getFrequencies(),letterFreq.getLetters());
	 
 }

 // BuildTree builds the Huffman tree based on the letter frequencies
 
 private HuffmanNode BuildTree(int[] frequencies,char[] letters) {
	 
	 
	/******** STEP 2 of Algorithm Huffman(X) **********************************/
	// we use a priority queue to store frequencies of subtrees created 
	// during the construction of the Huffman tree
	HeapPriorityQueue<HuffmanNode, HuffmanNode> heap = 
			new HeapPriorityQueue<HuffmanNode, HuffmanNode>(frequencies.length+1);
	 
    // initialize array leftWhereLetterIs 
	leafWhereLetterIs =new HuffmanNode[(int)'\uffff'+2]; // need 2^16+1 spaces
	for (int i=0; i< (int)'\uffff'+2; i++)
		leafWhereLetterIs[i]=null;
	
	/********* STEPS 3-5 of Algorithm Huffman(X) **********************************/
	// creating one node per letter as a single tree inserted into the priority queue
	for (int i=0; i<frequencies.length; i++) {
		if (frequencies[i]>0) {
			HuffmanNode node= new HuffmanNode( (int)letters[i], frequencies[i],null,null,null);
			leafWhereLetterIs[(int)letters[i]]=node;
			heap.insert(node,node);
		
		}
	}
	// creating node for "EndOfText" special symbol
	HuffmanNode specialNode= new HuffmanNode( EndOfText,0,null,null,null);
	leafWhereLetterIs[EndOfText]=specialNode; // last position reserved
	heap.insert(specialNode,specialNode);
	
	
	/************ STEPS 6-13 of Algorithm Huffman(X): task to be implemented ************/
	
	// Here comes the main algorithm to build Huffman tree
	while (heap.size() >1) {
		Entry<HuffmanNode,HuffmanNode> e1= heap.removeMin(); // e1 has smallest frequency
		Entry<HuffmanNode,HuffmanNode> e2= heap.removeMin(); // e2 has the second smallest frequency
		HuffmanNode kid1=e1.getValue(); // each entry of the priority queueu has the root of a tree
		HuffmanNode kid2=e2.getValue(); // 
		HuffmanNode node = new HuffmanNode(' ', kid1.getFrequency()+kid2.getFrequency(),null,kid1,kid2);// create parent
	    kid1.setParent(node);	//attach both kids
	    kid2.setParent(node);
	    heap.insert(node,node); // insert parent into priority queue
	}
	
	Entry<HuffmanNode,HuffmanNode> e= heap.removeMin(); // remove node with the final Huffman tree
	if (e==null) System.out.println("e is null!");
	
	return e.getValue(); // return the final Huffman tree
	
	
 }
 
// Encode the a character c using the Huffman tree
// returning its encoding as String of 0s and 1s representing the bits
// In the handout example if c='G' this method will return "011"
 
private String encodeCharacter(int c) {
	 
	 /*** Step in this method to be implemented by students ***/
	 HuffmanNode node=leafWhereLetterIs[c];
	 
	 String s=new String("");
	 
	 while ( node.parent()!=null) {
		 HuffmanNode p=node.parent();
		 if (p.leftChild()==node) // append 0 to the beginning
			 s = "0"+s;
		 else  // append 1 to the beginning
			 s = "1"+s;
		 node=p;
	 }
	 
	 return s;
 } 

// Encode the a character c using the Huffman tree
// sending the encoded bits to argument BitFeedOut bfo
// (please do not change this method)

 public void encodeCharacter (int c, BitFeedOut bfo) {
	 String s=encodeCharacter(c);
	 for (int i=0; i< s.length();i++) bfo.putNext(s.charAt(i));
	
 }
 
// receives Iterator<Byte> bit that iterates through a sequence
//  of bits of the  encoded string; this sequence must be
// compatible with the Huffman tree (has been previously generated by
// a tree like this one.
// This method will be "consuming" bits until it completes the
// decoding of a letter which is then returned.
// In the handout example, if the next bits are 011001...
// decodeCharacter will apply bit.next() 3 times until if decodes
// the first letter, which in this case is 'G'
 
public int decodeCharacter(Iterator<Byte> bit) {
	 
	 if (root == null) return Integer.MAX_VALUE; // empty tree is not valid when decoding
	 
	 /**** Steps of this method to be implemented by students ****/
	 
	 HuffmanNode current=root; // start from the root
	
	 while (true) {
	        if (current.isLeaf()) { // whean a leaf is reached a character was decoded
	        	 return current.getLetter();
	        }
	        else { 
	        	// traverse to left or right depending on the bit being 0 or 1
	        	if (bit.hasNext()) {
	        		byte b=bit.next();
	        		if (b==0) current=current.leftChild();
	        		else if (b==1) current=current.rightChild();
	        		else return Integer.MAX_VALUE;
	        	}
	        	else return Integer.MAX_VALUE;
	        }
		 
		 
	 }
 }
 
 
 
 // auxiliary methods for printing the codes in the Huffman tree

 void printCodeTable() {
	 System.out.println("**** Huffman Tree: Character Codes ****");
	 if (root!=null) 
		 traverseInOrder(root,""); // uses inorder traversal to print the codes
	 else 
		 System.out.println("No character codes: the tree is still empty");
	 System.out.println("***************************************");
	 
 }
 
 // In-order traversal of the Huffman tree keeping track of
 // the paths to leaves so it can print the codeword for each letter
 private void traverseInOrder(HuffmanNode current, String c) {
	 if (current.isLeaf()) {
		if (current.getLetter()!=EndOfText)
		       System.out.println((char)current.getLetter()+":"+c);
		else   System.out.println("EndOfText:"+c);
	 }
	 else { 
		 traverseInOrder(current.leftChild(),c+"0");
		 traverseInOrder(current.rightChild(),c+"1");
	 }
		 
 }
 
 // provided byte encoding of the frequency information
 // in the format of 4 bytes per letter
 // 2 first bytes represent letter 2 last bytes represent frequency
 // This is useful for file decoding where the letter frequencies need
 // to be stored in a "header" of the encoded file 
 // (not used in the current version of the assignment)
 
 byte[] freqsToBytes() {
    int b=0;
	byte [] treeBytes= new byte[(int)'\uffff'*4];
    for (int i=0;i<'\uffff';i++) {
		if (leafWhereLetterIs[i]!=null) {
			int freq=leafWhereLetterIs[i].getFrequency();
			char letter=(char)leafWhereLetterIs[i].getLetter();
			treeBytes[b++]= (byte)(((int)letter)/256);
			treeBytes[b++]= (byte)(((int)letter)%256);
			treeBytes[b++]= (byte)(freq/256); 
			treeBytes[b++]= (byte)(freq%256);			
		}
	}
    return Arrays.copyOf(treeBytes, b);
 }
 
 	/**** inner class to Huffman tree that implements a Node in the tree ****/
    // nothing to be changed in this inner class
 	public class HuffmanNode implements Comparable<HuffmanNode> {
		
		int letter; // if the node is a leaf it will store a letter, otherwise it store null
	    int frequency; // stores the sum of the frequencies of all leaves of the tree rooted at this node
		private HuffmanNode parent, left, right; // reference to parent, left and right nodes.
		
		public HuffmanNode() {
			parent=left=right=null;
			frequency=-1;
		}
		
		public HuffmanNode(int letter, int frequency, HuffmanNode parent, HuffmanNode left, HuffmanNode right) {
			this.letter= letter;
			this.frequency=frequency;
			this.parent=parent; 
			this.left=left;
			this.right=right;
		}
		
		
		boolean isLeaf() { return (left==null && right==null);}
		
		// getter methods
		
		HuffmanNode leftChild() { return left;}
		
		HuffmanNode rightChild() { return right;}
		
		HuffmanNode parent() { return parent;}
		
		int getLetter() {return letter;}
		
		int getFrequency() {return frequency;}

		// setter methods
		
		void setLeftChild(HuffmanNode leftVal) { left=leftVal;	}
		
		void setRightChild(HuffmanNode rightVal) { right=rightVal;	}
		
		void setParent(HuffmanNode parentVal) { parent=parentVal;	}
		
		void setLetter(char letterVal) { letter = letterVal;}
		
		void setFrequency(int freqVal) { frequency = freqVal; }

		@Override
		public int compareTo(HuffmanNode o) {
			if (this.frequency==o.frequency) {
				return this.letter-o.letter;
			}
			else return this.frequency-o.frequency;
			
		}
		
	}

 
 
}
 
